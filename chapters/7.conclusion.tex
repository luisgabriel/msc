\chapter{Conclusion}\label{chp:conclusion}
This chapter present our conclusion remarks.

\section{Contributions}
In this work, we have shedded light on the energy behavior of concurrent Haskell programs. To the best of our knowledge, this is the first attempt to analyze energy efficiency in the context of functional programming languages. Moreover, this work makes the following contributions:

\begin{itemize}
  \item \textbf{A tool for fine-grained energy analysis.} We have extended the \acs{ghc} profiler to collect and report fine-grained information about the energy consumption of a Haskell program;
  \item \textbf{A tool for coarse-grained energy analysis.} We have extended the Criterion microbenchmarking library to collect, perform and report statistical performance analysis of the energy consumption of Haskell code;
  \item \textbf{An understanding of the energy behavior of concurrent Haskell programs.} We have conducted an extensive experimental space exploration illuminating the relationship between the choices and settings of Haskell's concurrent programming constructs, and performance and energy consumption over both microbenchmarks and real-world Haskell programs;
  \item \textbf{A list of guidelines on how to write energy-efficient software in Haskell.} We have provided some recommendations for helping software developers to improve the energy efficiency of their concurrent Haskell programs.
\end{itemize}

An earlier version of \textbf{\chapref{chp:study}} of this dissertation has been one of the core contributions of a paper that has been published at the main research track of the \emph{IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER'16)}~\cite{lima:2016}. An updated version of this paper including the extensions that we made and the remainder of this dissertation is under work to be submitted to a software engineering journal.

We hope our findings will ease the development of energy-efficient Haskell programs. We also hope that this work motivates other developers and researchers from the functional programming and software engineering communities to engage in exploring the software energy consumption area.


\section{Future Work}
For improving the developers' tooling, a natural next step is enabling the \ac{ghc} energy profiler to properly analyze the energy consumption of parallel programs. This involves developing a software model for estimating the energy consumed by each CPU core based on the energy consumed by all cores. This technique could also be incorporated into the parallel profiling system of \ac{ghc} to add energy information to the trace file format. It would allow us to extend the ThreadScope tool to make it energy-aware. We plan to investigate this further because we believe that fine-grained energy analysis has the potential to improve significantly the developers' knowledge about software energy consumption, especially with visualization tools such as ThreadScope and \texttt{ghc-events-analyze}.

For the concurrent programming constructs, we intend to replicate our study on different hardware. Newer Intel microarchitectures such as Haswell and Broadwell have shown significant improvement over the previous generations regarding power management~\cite{huang:2015}. We want to investigate if these changes have consequences on the energy behavior of our benchmarks. We also want to explore how the various \ac{ghc} options available for both the compiler and the runtime system can affect the energy consumption and performance of concurrent programs. These options enable the customization of several different aspects of the compilation and execution process, which can have a direct impact on energy consumption. Additionally, we plan to do an in-depth analysis of each benchmark of our suite to better understand its characteristics and how they differ among themselves. This can lead to the addition of new benchmarks to our suite so we can improve its diversity. Another idea under our radar is to investigate the energy behavior of other concurrent programming models that are popular in functional programming languages such as the Actor Model~\cite{agha:1986}.
