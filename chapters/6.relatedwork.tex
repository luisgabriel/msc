\chapter{Related Work}\label{chp:related}
In this chapter, we present a short description of the research which has been conducted in areas related to our work.


\section{Performance Analysis in Haskell}
\citeonline{runciman:1993} introduced the first heap profiler for a lazy functional language on the Chalmers hbc/lml compiler. Later, \citeonline{sansom:1995} evolved this idea for the \ac{ghc} profiler. Besides a heap profiler, they also introduced a time profiler and created the notion of cost centres. \citeonline{morgan:1998} extended the \ac{ghc} profiler with the notion of cost centre stacks for defining a hierarchy of cost centres, similar to a call graph. In this work, we take advantage of all this infrastructure provided by the \ac{ghc} profiler to add energy consumption as a new profiling metric.

\citeonline{jones:2009} developed a parallel profiling system for \ac{ghc}. It defines a trace file format and a tool for visualizing parallel execution. This tool is called ThreadScope, and it enables developers to see a visual representation of the program execution by showing the activity of each capability and other events from the runtime system such as garbage collection. \citeonline{devries:2014} created a tool called \texttt{ghc-events-analyze} that uses the same trace file for generating a different visualization of the program's execution. It lets developers view the CPU activity across all Haskell threads while ThreadScope shows the CPU activity across all capabilities. It also enables developers to label periods of time during program execution by instrumenting the source code with special trace calls. We did not explore these parallel profiling tools on our work. The main reason for that is that \ac{rapl}, the engine we used for collecting energy data, does not provide fine-grained energy information by cores, only the cores combined. Estimating the energy consumed by each core based on the \ac{rapl} readings is an interesting idea that we aim to tackle in the future.

\citeonline{partain:1992} introduced the \texttt{nofib} benchmark suite for Haskell. This was the first attempt to build a benchmark suite for enabling a quantitative performance assessment of lazy functional programming systems. Currently, \texttt{nofib} is integrated with \ac{ghc} for guaranteeing no major performance regressions in new releases. From time to time, new benchmarks are added to the suite to keep it up-to-date with the language evolution. Some of the benchmarks from \acl{clbg} that we employed in our study are also part of the \texttt{nofib} suite. \citeonline{sullivan:2009b} created Criterion, a new library for measuring the performance of Haskell code. It uses a robust statistical framework for performing reliable performance analysis. We extended this tool also to work with energy consumption. We also employed it heavily in our empirical study.


\section{Software Energy Consumption}
Studying energy efficiency at the application level is an emerging direction. Traditionally, this problem has been tackled at the lower levels of the computer stack. For example, for building energy-efficient solutions for embedded software~\cite{tiwari:1994}, compilers~\cite{hsu:2003}, operating systems~\cite{merkel:2006}, and runtime systems~\cite{ribic:2014, farkas:2000}. The programming language community has also been active researching this topic through the design of energy-aware programming languages such as Eon~\cite{sorber:2007}, Green~\cite{baek:2010}, EnerJ~\cite{sampson:2011}, and Energy Types~\cite{cohen:2012}. In this kind of approach, the energy behavior information is encoded in the language as a first-class citizen. We take a different route in our work by trying to educate developers on writing energy-efficient software using the tools and languages that they already use.

Several related works study the impact of software changes on energy consumption. \citeonline{hindle:2012} studied the effects of Mozilla Firefox's code evolution on its energy efficiency, showing a consistent reduction in energy usage correlated to performance optimizations. \citeonline{pinto:2014} studied the energy consumption of different thread management primitives in the Java programming language. We took a similar route in assessing the consumption for Haskell's thread management and data sharing constructs. \citeonline{sahin:2014} provide an analysis of the effects of code refactorings on energy consumption for nine Java applications. For six commons refactorings, such as converting local variables to fields, they showed an impact on energy consumption that was difficult to predict. Our work focuses on Haskell programs and the impact of changes regarding concurrent structures used. Those changes could be expressed as refactorings since the compared versions have the same program behavior.

\citeonline{kwon:2013} reduced the energy consumption of mobile apps by offloading part of their computation transparently to programmers. \citeonline{moura:2015} studied the commit messages of 317 real-world non-trivial applications to infer the practices and needs of current application developers. A recurring theme identified in this study is the need for more tools to measure/identify/refactor energy hotspots. \citeonline{manotas:2014} described an automated support for systematically optimizing the energy usage of applications by making code-level changes. \citeonline{bruce:2015} used Genetic Improvement to reduce the energy consumption of applications, reaching up to 25\% reduction. Both \citeonline{pinto:2016} and \citeonline{pereira:2016} studied the energy characteristics of several collections of the Java programming language. The former analyzed it under the concurrency point-of-view, studying 16 thread-safe collections, while the latter studied other collections from the Java Collection Framework in sequential scenarios. All these approaches show the potential for program transformation, in general, and refactorings, in particular, to reduce energy consumption. We explored this potential further in this work by targeting Haskell's concurrency framework.


\section{Refactoring}
\citeonline{murphy-hill:2009} provide an analysis on the use of refactoring. Their study indicates how refactoring is common, even if only executed manually. \citeonline{dig:2011} present some reasons why developers choose to apply program transformations to make their programs concurrent. They studied five open-source Java projects and found four categories of concurrency-related motivations for refactoring: Responsiveness, Throughput, Scalability and Correctness. Their findings show that the majority of the transformations (73.9\%) consisted of modifying existing project elements, instead of creating new ones. Our work shows that modifying existing elements can also lead to energy savings, yet another motivation for refactoring.

Various papers address the problem of refactoring Haskell programs. \citeonline{li:2005} present the Haskell Refactorer infrastructure to support the development of refactoring tools. \citeonline{lee:2011} used a case study to classify 12 types of Haskell refactorings found in real projects, mostly dealing with maintainability. \citeonline{brown:2011} specified and implemented refactorings for introducing parallelism into Haskell programs, considering mainly performance concerns. \citeonline{soares-neto:2014} described refactorings for rewriting concurrent Haskell programs to \ac{stm}. Just as mentioned previously, our study may influence future Haskell program maintenance as energy efficiency becomes a mainstream concern. We are not aware of previous work analyzing the energy efficiency of Haskell programs, in particular, or purely functional programming languages, in general.
