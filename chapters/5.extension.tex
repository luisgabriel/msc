\chapter{A Guideline for Developers}
\lipsum[1-2]


\section{Use \forkOn for embarrassingly parallel problems}
\sstate{Description:} Both the performance and energy consumption of a program can be improved by using \forkOn to create new threads of execution when there is little or no dependency among these threads and they perform almost the same amount of work.
\newline

\sstate{Rationale:} A problem that can be decomposed into parallel tasks that do not need to communicate with each other to make progress is called \emph{embarrassingly parallel}~\cite{herlihy:2012}. Three of the benchmarks from \chapref{chp:study} fits this description: \mandelbrot, \regex and \spectral. The results from our study has shown that, for these benchamrks, the variants using \forkOn superseded the others in both performance and energy consumption. This result shows that manually distributing the workload in an even manner among the capabilities instead of handing this job to the runtime system scheduler improves performance. It makes sense because we know before hand that each worker thread is doing exactly the same amount of work. In such scenarios, there is no need for migrating a thread from one capability to another since an even distribution is the one which contributes the most for the program's progress. It makes sure that each capability will have the same workload. So using \forkOn in these cases reduces the overhead incurred by the Haskell runtime system.

\begin{figure*}[tp]
\caption{Performence of \mandelbrot and \spectral with different number of workers}
\centering
$
\begin{array}{ccc}
 \includegraphics[width=.48\textwidth]{images/conc_bench/mandelbrot-Xt-energy} &
 \includegraphics[width=.48\textwidth]{images/conc_bench/spectral-norm-Xt-energy} \\

 \includegraphics[width=.48\textwidth]{images/conc_bench/mandelbrot-Xt-time} &
 \includegraphics[width=.48\textwidth]{images/conc_bench/spectral-norm-Xt-time} \\
\end{array}
$
\footnotesize{Source: Made by the author}
\label{fig:more-threads}
\end{figure*}

However, \regex is implemented diffenrently from \mandelbrot and \spectral. The first one uses a fixed number of worker threads (350) while the others the number of threads can be set by the developer. For the experiments of \chapref{chp:study}, we set these benchmarks to spawn as many threads as the number of capabilities. We decided to run another experiment with \mandelbrot and \spectral to check how they behave if we overpopulate the capabilities' work queue. In \figref{fig:more-threads}, we can see the results for the \forkOn-\MVar variant of both benchmarks with $N$, $1.5N$ and $2N$ worker threads, where $N$ is the number of capabilities. As we can see, although the performance is similar, one thread per capability is the configuration with the best performance. This result makes sense because it reduces the costs of context-switching between threads of the capabilities' work queue. Thus, creating one worker thread per capability benefits both performance and energy consumption.

\begin{figure*}[tp]
\caption{Performence of \regex and \spectral using \texttt{-qa} and \texttt{-qm}}
\centering
$
\begin{array}{ccc}
 \includegraphics[width=.48\textwidth]{images/conc_bench/regex-dna-qX-energy} &
 \includegraphics[width=.48\textwidth]{images/conc_bench/spectral-norm-qX-energy} \\

 \includegraphics[width=.48\textwidth]{images/conc_bench/regex-dna-qX-time} &
 \includegraphics[width=.48\textwidth]{images/conc_bench/spectral-norm-qX-time} \\
\end{array}
$
\footnotesize{Source: Made by the author}
\label{fig:rts-flags}
\end{figure*}

Additionally, there are two \ac{rts} options that, in conjunction with \forkOn, can affect the performance of some embarrassingly parallel algorithms. The first one is the \texttt{-qa} option. It tries to pin OS threads to CPU cores using native OS facilities\footnote{In Linux, GHC uses the \texttt{sched\_setaffinity()} syscall}. Using this option, the OS threads associated with a capability \emph{i} are bound the CPU core \emph{i}. The other one is the \texttt{-qm} option. It disables automatic migration of threads between CPUs. The former seems to fit perfectly in this context since it increases the probability of a Haskell thread being kept running on the same CPU core during the execution of the program. However, it is not clear how different the latter is from simply creating all threads with \forkOn as we are proposing here. To get a picture of their influence, we executed our embarrassingly parallel benchmarks with these options. In \figref{fig:rts-flags} we show results for the \forkOn-\MVar variant of both \regex and \spectral. Here, we executed the benchmarks without either of the options, only with \texttt{-qa}, only with \texttt{-qm}, and with both options. As we can see, the \ac{rts} options affect the performance of both benchmarks. However, the behavior is not predictable. In \spectral, using only \texttt{-qa} improves both performance and energy consumption regardless of the number of capabilities. In \regex, however, using any combination of the \ac{rts} options has a negative impact on performance. It also increases considerably the energy consumption for more than eight capabilities. We recommend developers to experiment with these options to assess how they affect the performance of a given program.


% XXX: may change this tip to suggest the number of capabilities to be used?
\section{Avoid setting more capabilities than available CPUs}
\sstate{Description:} [[ TODO ]]
\newline

\sstate{Rationale:} [[ TODO ]]


\section{Avoid using \forkOS to spawn new threads}
\sstate{Description:} [[ TODO ]]
\newline

\sstate{Rationale:} [[ TODO ]]
